
title: "Nature vs Golang: 性能基准测试"
date: 2026-01-15

在过去的 0.7 版本中，我对 nature 的整体性能进行了优化，包括 TCP/UDP/HTTP、CPU、String、GC、Closure 等。并在版本发布后完成了一次和其他编程语言的性能对比测试，让开发者对 nature 的性能有着更加清晰的认知。

相关测试代码放在 https://github.com/nature-lang/benchmark  仓库中。这是首次性能测试，所以没有将 nature 的历史版本作为对比。因为 **nature 和 go 采用了相同的架构设计，所以使用最新版本的 go 作为基准进行测试**，并且在合适的领域中引入了 rust 和 node.js 进行参照，从而避免机器性能带来的误导。

## 测试环境

| 配置项         | 详情                                                               |
| ----------- | ---------------------------------------------------------------- |
| 宿主机         | Apple Mac mini M4，16GB 内存                                        |
| 测试环境        | Linux 虚拟机 ubuntu 6.17.8 aarch64  8G 内存                           |
| 编译器 / 运行时版本 | Nature：v0.7.2<br>Golang：1.25.5<br>Rust：1.92.0<br>Node.js：v25.2.0 |
## IO

使用语言标准库编写一个简单的 HTTP Server

**nature 代码示例**

```nature
import http.{server, request_t as req_t, response_t as resp_t}
  
fn main() {  
    var app = server()  
  
    app.get('/', fn(req_t req, ptr<resp_t> res):void! {  
        res.send('hello nature')  
    })  
  
    app.listen(8888)  
}
```

**测试命令** `ab -n 100000 -c 1000 http://127.0.0.1:8888/`

**测试结果**

![](https://raw.githubusercontent.com/weiwenhao/pictures/main/20260115124607863.png)

HTTP Server 是对编程语言性能的综合测试，其中涉及到了内存分配器、GC、数据结构、协程调度器和 IO 循环处理等。

nature 在这方面的表现非常优秀，相比于 go 也有着一定的领先。在技术架构上 **nature 采用了 libuv 作为 IO 后端**，这和 node.js 一致，但 nature 作为 AOT 编程语言相比于 JIT 编程语言在综合性能上有着天然的优势。

如果你想快速体验使用 nature 开发 api 可以参考 https://github.com/weiwenhao/emoji-api 这个项目。

## CPU

使用 leibniz 公式计算 10 亿次 PI

**nature 代码示例**

```nature
import syscall
import fs
import strings
import fmt

fn main() {
    var f = fs.open('./rounds.txt', syscall.O_RDONLY, 0).content()
    var rounds = f.trim([' ', '\n']).to_int()
    var x = 1.0
    var pi = 1.0
    int stop = rounds + 2

    for int i = 2; i <= stop; i+=1 {
        x = -x
        pi += x / (2 * i - 1) as f64
    }

    pi *= 4.0
    fmt.printf('%.16f', pi)
}
```

**测试命令** `hyperfine --warmup 3 ./pi_n ./pi_go ./pi_rs "node main.js"`

**测试结果**

![](https://raw.githubusercontent.com/weiwenhao/pictures/main/20260115124630317.png)
这是一个简单的 CPU 计算测试，在我看来这主要考验的是编程语言的寄存器分配的利用率。rust 采用了 Greedy 图着色变体寄存器分配算法，**nature/go/nodejs 则都是线性扫描寄存器分配算法**。由于循环中没有函数调用不涉及到寄存器溢出，所以这方面 nature 和 go 都做的非常不错。

## Recursion

使用经典的递归斐波那契数列计算 `fib(45)` 来测试语言的高频函数调用开销。

**测试命令** `hyperfine --warmup 3 --runs 5 ./fib_n ./fib_go ./fib_rs "node fib.js"`

**测试结果**

![](https://raw.githubusercontent.com/weiwenhao/pictures/main/20260115124653382.png)
nature 和 go 采用自研的编译器后端，性能上相差无几。耗时上高于 rust 的原因之一是需要在函数运行前进行前置处理。比如 go 需要处理栈扩容

```
// more stack
f9400b90 	ldr	x16, [x28, #16]
eb3063ff 	cmp	sp, x16
540002a9 	b.ls	7869c <main.Fib+0x5c>  // b.plas
```

而 nature 需要处理 GC safepoint

```
400284:	d0003490 	adrp	x16, a92000 // global safepoint
400288:	f9474210 	ldr	x16, [x16, #3712]
40028c:	b5000250 	cbnz	x16, 4002d4 <main.preempt>
```

**go 采用了基于主动信号的抢占式调度**，所以不需要在指令运行过程中插入 safepoint，这让其指令运行和函数调用速度得到了进一步提升。但是由于 go 采用了独立栈协程，不得不在函数调用时考虑栈空间是否足够的问题。

而 nature 没有选择信号式抢占式调度，而是**协作式调度为主 + safepoint 指令抢占的方式**，这在某些极端场景下可能导致 GC 阻塞，但也有着更高的自由度和可控性。

至于为什么需要抢占或者 safepoint，则涉及到经典的 GC STW 问题，现代编程语言的 GC 基本采用并发模式，这需要在某一个关键时刻暂停所有的线程，然后安全的开启写屏障。即使这非常短暂 STW，但依旧成为被开发者们诟病的问题。

而在协程栈的设计上，又是一个非常有趣的选择问题，**无栈协程有着极致的性能但存在 async 污染问题，独立栈协程避免了 async 污染，但是性能和内存使用上存在劣势。而共享栈协程则是两者中间的产物，更好的性能和内存占用，同时也不存在 async 污染。**

## C FFI

通过调用 1 亿次 C 标准库中的 sqrt 函数，测试与 C 语言的协作效率。

`
**nature 代码示例**

```nature
import libc  
  
fn main() {  
    for int i = 0; i < 100000000; i+=1 {  
        var r = libc.sqrt(4)  
    }  
}
```

**测试命令** `hyperfine --warmup 3 --runs 5 ./ffi_n ./ffi_go`

**测试结果**

![](https://raw.githubusercontent.com/weiwenhao/pictures/main/20260115124713413.png)

令人惊叹的性能差距，**go 的独立栈 + 信号主动抢占设计**，使其与 C 及其他遵循 ABI 规范的库存在兼容性问题。

而 nature 实现了完整的 ABI 规范和类型映射，并且共享栈的协程设计让 **nature 可以无损耗的调用符合 ABI 规范的代码库**。

在高性能计算、底层硬件操作等场景中，**nature 可以无缝集成 C / 汇编编写的核心模块**，弥补 GC 语言在极致性能场景下的不足，兼顾开发效率与底层性能。

## 协程

nature 在设计上继承了 go 的优秀理念，这包括协程。通过百万协程创建 + 切换 + 简单计算的场景，评估 nature 与 go 的协程调度效率、内存占用与响应速度。

**nature 代码示例**

```nature
import time  
import co  
  
var count = 0  
  
fn sum_co() {  
    count += 1  
    co.sleep(10000) 
}  
  
fn main() {  
    var start = time.now().ms_timestamp()  
    for int i = 0; i < 1000000; i+=1 {  
        go sum_co()  
    }  
  
    println(time.now().ms_timestamp() - start)  // create time
    
    int prev_count = 0  
    for prev_count != count {  
        println(time.now().ms_timestamp() - start, count)  
        prev_count = count  
        co.sleep(10)  
    }  
    println(time.now().ms_timestamp() - 10 - start) // calc time
} 
```

**测试结果**

![](https://raw.githubusercontent.com/weiwenhao/pictures/main/20251222101802914.png)

得益于共享栈协程技术，**nature 在协程综合性能上非常优秀，内存占用更是远低于 go**。并且由于 nature 在协程测试中的表现不错，所以在本次版本中实际并未对协程进行任何的优化，nature 的协程在内存占用、结构体设计等等地方依旧有着非常大的优化空间。


## 总结

通过上面的语法示例和基准测试图表，你对 nature 编程语言有了更加清晰的认知。在基准测试中，nature 已经有着非常优秀的表现，并且作为早期编程语言其 runtime 和编译器依旧有着非常大的优化空间。

**即使你不打算使用 nature，nature 也是值得关注的新兴编程语言，尤其是在云原生、网络服务、API 开发、Agent 开发、命令行工具、基础设施建设等领域。**  

**作为通用编程语言，做的更多是 nature 的核心目标**，后续将会推动的关键特性有

- **转换为可读的 go 编程语言**，从而利用 go 生态，这是一件令人无奈的事情，但为了 nature 的可用性必须去做；

- **GUI 库适配：** 在保留现有事件循环机制的前提下，让 Nature 更好地兼容 C/C++ GUI 库，同时保证 GC 正确性，提供可用的 GUI 开发库；

- **WASM3.0 适配:** WASM3.0 已经支持 GC，这让 nature 可以抛弃复杂的 runtime 直接将 AST 翻译为 WASM 后端；

- **可控的内存分配器与 unsafe 裸函数支持：** 这是实现 GUI/ WASM3.0 适配的基础，若设计得当，nature 将真正成为可用于高性能系统开发的系统级编程语言；

- **AI 适配：** 将 AI 作为 Nature 的代码助手，使其能编写正确且优雅的 Nature 代码，包括优化错误提示、完善测试能力、构建可检索的标准库文档等；

- **AI 编码可验证性探索：** 这是 nature 的关键目标。并且和上述的 AI 适配是完全不同的工作，该特性完成后，nature 编程语言将会成为最合适 LLM 编写代码的编程语言之一；

nature 是由社区驱动且**开放与自由**的编程语言，能够接纳先进甚至激进的技术迭代方式；并且支持 AI 辅助编程贡献代码(**使用 cladue opus4.5+ 或同等模型并做好代码审查和测试**) 。

如果你对上面任意的工作感兴趣或者有想法，欢迎提交 github issue 或者通过邮件 wwhacker@qq.com 与我沟通。🍻